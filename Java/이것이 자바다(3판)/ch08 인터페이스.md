# 8 인터페이스

## 8.1 인터페이스의 역할

- 인터페이스(interface): 두 장치를 연결하는 접속기

  > 두 객체를 연결하는 역할을 한다.
  
- 인터페이스와 클래스의 주요 차이점

  - 인스턴스 생성
    - 클래스: 인스턴스 생성 가능
    - 인터페이스: 인스턴스 직접 생성 불가능

  - 메소드 구현
    - 클래스: 모든 메소드 구현 가능
    - 인터페이스: 기본적으로 추상 메소드만 정의, 디폴트 메소드와 정적 메소드 추가(자바 8)

  - 다중 상속
    - 클래스: 단일 상속만 허용
    - 인터페이스: 다중 상속 가능

  - 필드
    - 클래스: 인스턴스 변수와 클래스 변수를 가질 수 있음
    - 인터페이스: 상수만 가질 수 있음


---

## 8.2 인터페이스와 구현 클래스 선언

#### 8.2.1 인터페이스 선언

- class 키워드 대신 interface 키워드 사용

#### 8.2.2 구현 클래스 선언

- 구현 클래스 뒤에 implements 인터페이스명 사용

#### 8.2.3 변수 선언과 구현 객체 대입

- 인터페이스 변수에 구현 객체를 대입해야 한다.

---

## 8.3 상수 필드

- ```[ public static final ] 타입 상수명 = 값;```

  > 인터페이스에서 선언된 필드는 모두 상수이다.
  
  - 인터페이스는 메소드가 다른 패키지에서도 재사용성을 갖기 위해 메소드에 public 키워드가 있으므로 필드도 있어야만 한다.
  
  - 인터페이스는 힙 영역에 메모리 공간이 없기 때문에 static 키워드가 있어야만 한다.
  - 인터페이스는 일관성을 유지하고 메소드만을 정의하기 위해 final 키워드가 있어야만 한다.

---

## 8.4 추상 메소드

- ```[ public abstract ] 리턴타입 메소드명(매개변수, ...);```

  > 인터페이스에서 선언된 메소드는 기본적으로 추상 메소드이다.
  
  - 인터페이스는 특정 기능을 제공하기 위한 계약과 같은 것이기 때문에 다른 패키지에서도 재사용성을 갖기 위해 public 키워드가 있어야만 한다.
  - 인터페이스는 특정 기능을 제공하기 위한 계약과 같은 것이기 때문에 구현 클래스가 재정의해야 하는 abstract 키워드가 있어야만 한다.
  
- 자식 메소드에서 메소드에 항상 public 키워드를 붙여야 한다.

---

## 8.5 디폴트 메소드

- 디폴트 메소드: 완전한 실행 코드를 가진 메소드

  ```[ public ] default 리턴타입 메소드명(매개변수, ...) { ... }```

  - 실행 코드가 자식 메소드에 있을 때는 abstract, 인터페이스에 있을 때는 default이다.

---

## 8.6 정적 메소드

- 정적 메소드

  ```[ public | private ] static 리턴타입 메소드명(매개변수, ...) { ... }```

---

## 8.7 private 메소드

- private 메소드: default 메소드 안에서 호출 가능
- private static 메소드: default 메소드, static 메소드 안에서 호출 가

---

## 8.8 다중 인터페이스 구현

- 구현 객체는 여러 개의 인터페이스를 implements 할 수 있다.

---

## 8.9 인터페이스 상속

- 클래스와 달리 다중 상속을 허용한다.

  ```public interface 자식인터페이스 extends 부모인터페이스1, 부모인터페이스2 { ... }```

---

## 8.10 타입 변환

#### 8.10.1 자동 타입 변환

- 자동 타입 변환(promotion): 인터페이스 변수 = 구현객체;

#### 8.10.2 강제 타입 변환

- 강제 타입 변환(casting): 구현클래스 변수 = (구현클래스) 인터페이스변수;

---

## 8.11 다형성

#### 8.11.1 필드의 다형성

- 필드 타입을 인터페이스로 선언하고 다양한 자식 객체를 대입한다.

#### 8.11.2 매개변수의 다형성

- 매개변수 타입을 인터페이스로 선언하고 호출할 때에는 다양한 자식 객체를 대입한다.

```java
public interface Tire {}
public class HankookTire implements Tire {}
public class KumhoTire implements Tire {}
public class Car {
    Tire tire = new Tire();
    void roll(Tire tire) {}
}
public class CarExample {
    public static void main(String[] args) {
        Car myCar = new Car();
        
        // 필드의 다형성
        myCar.tire = new HankookTire();
        myCar.tire = new KumhoTire();
        
        // 매개변수의 다형성
        myCar.roll(new HankookTire());
        myCar.roll(new KumhoTire());
    }
}
```



---

## 8.12 객체 타입 확인

- instanceof 연산자: ```if (인터페이스변수 instanceof 구현클래스명) {}```

  > ```구현클래스명 구현클래스변수 = (구현클래스명) 인터페이스변수; // 구현클래스명 뒤에 구현클래스변수만 붙이면 됨```

---

## 8.13 봉인된 인터페이스

- ```public sealed interface 인터페이스명 permits 자식인터페이스명 { ... }```
- ```public non-sealed interface 자식인터페이스명 extends 인터페이스명 { ... }```
  - permits된 인터페이스는 non-sealed, sealed 중 하나를 사용해야 한다.

---

